
# Spring PetClinic - Comprehensive Architectural Summary

## 1. Executive Overview

### Application Profile
- **Framework**: Spring Boot 3.5.0 with Java 17
- **Architecture Pattern**: Traditional monolithic with layered design
- **Primary Technology Stack**: Spring MVC, JPA/Hibernate, Thymeleaf
- **Build Systems**: Maven (primary) with full Gradle support
- **Deployment Targets**: Executable JAR, Docker containers, Kubernetes, Docker Compose

### Core Business Domains
1. **Owner Management**: Customer data and contact information
2. **Pet Management**: Pet records with medical history
3. **Veterinary Management**: Veterinarian profiles and specialties
4. **Visit Management**: Medical appointments and treatments

## 2. Domain Model Architecture

### Entity Hierarchy
```java
BaseEntity (Abstract)
├── NamedEntity (Abstract)
│   ├── PetType
│   └── Specialty
├── Person (Abstract)
│   ├── Owner
│   └── Vet
└── Visit
```

### Entity Specifications
- **BaseEntity**: Auto-generated ID (IDENTITY strategy), implements Serializable
- **NamedEntity**: Extends BaseEntity with required name field
- **Person**: Extends BaseEntity with firstName/lastName validation
- **Owner**: Extends Person with:
  - Fields: address, city, telephone (exactly 10 digits)
  - Relationships: one-to-many to Pet
- **Vet**: Extends Person with:
  - Relationships: many-to-many to Specialty
- **Pet**: NamedEntity with:
  - Fields: birthDate (cannot be future)
  - Relationships: many-to-one to PetType, many-to-one to Owner, one-to-many to Visit
- **Visit**: BaseEntity with:
  - Fields: LocalDate visitDate, String description
  - Relationships: many-to-one to Pet
- **PetType**: Simple named entity for pet categorization
- **Specialty**: Simple named entity for veterinary specialties

### Data Transfer Objects
- **Vets**: Wrapper collection for vet serialization (XML/JSON support)

## 3. Database Architecture

### Multi-Database Support
- **H2**: Default in-memory database
- **MySQL**: Activated via `spring.profiles.active=mysql`
- **PostgreSQL**: Activated via `spring.profiles.active=postgres`

### Schema Management
- **Location**: `/src/main/resources/db/{database}/`
- **Files**: `schema.sql` (DDL), `data.sql` (initial data)
- **Profile Configuration**: Database switching via Spring profiles

### Core Tables
```sql
owners (id, first_name, last_name, address, city, telephone)
pets (id, name, birth_date, type_id, owner_id)
types (id, name)
visits (id, pet_id, visit_date, description)
vets (id, first_name, last_name)
specialties (id, name)
vet_specialties (vet_id, specialty_id)
```

### Repository Pattern Implementation
```java
OwnerRepository extends JpaRepository<Owner, Integer>
├── findByLastNameStartingWith(String, Pageable)
└── findById(Integer)

PetRepository extends JpaRepository<Pet, Integer>
└── findById(Integer)

PetTypeRepository extends JpaRepository<PetType, Integer>
└── findPetTypes() (ORDER BY name)

VisitRepository extends JpaRepository<Visit, Integer>
└── findByPetId(Integer)

VetRepository extends JpaRepository<Vet, Integer>
└── @Cacheable("vets")
└── findAll(Pageable)
└── findAll()

SpecialtyRepository extends JpaRepository<Specialty, Integer>
```

## 4. API Architecture

### Controller Layer Components

#### Owner Management Endpoints
| Method | Path | Purpose |
|--------|------|---------|
| GET | `/owners/find` | Search form |
| GET | `/owners` | Find owners with pagination |
| GET | `/owners/{ownerId}` | Owner details view |
| GET | `/owners/new` | Create owner form |
| POST | `/owners/new` | Create owner |
| GET | `/owners/{ownerId}/edit` | Update owner form |
| POST | `/owners/{ownerId}/edit` | Update owner |

#### Pet Management Endpoints
| Method | Path | Purpose |
|--------|------|---------|
| GET | `/owners/{ownerId}/pets/new` | Create pet form |
| POST | `/owners/{ownerId}/pets/new` | Create pet |
| GET | `/owners/{ownerId}/pets/{petId}/edit` | Update pet form |
| POST | `/owners/{ownerId}/pets/{petId}/edit` | Update pet |

#### Visit Management Endpoints
| Method | Path | Purpose |
|--------|------|---------|
| GET | `/owners/{ownerId}/pets/{petId}/visits/new` | Create visit form |
| POST | `/owners/{ownerId}/pets/{petId}/visits/new` | Create visit |

#### Veterinary Management Endpoints
| Method | Path | Response | Purpose |
|--------|------|----------|---------|
| GET | `/` | View (welcome) | Home page |
| GET | `/vets.html` | View (HTML) | Paginated vet listing (5/page) |
| GET | `/vets` | JSON | Full vet list (API) |

#### Error Handling
- `GET /oups` - Controlled exception endpoint (CrashController)

## 5. Business Logic & Validation

### Core Business Rules
- **Pet Name Uniqueness**: Must be unique within owner's pet collection
- **Telephone Validation**: Exactly 10 digits required
- **Birth Date Constraints**: Cannot be future dates
- **Visit Date Defaults**: Defaults to current date if not specified

### Validation Components
- **PetValidator**: Custom validator for pet-specific constraints
- **Bean Validation**: Standard JSR-380 annotations on entities
- **Form Validation**: Spring MVC validation integration

### Data Conversion
- **PetTypeFormatter**: String ↔ PetType bidirectional conversion for forms

## 6. Configuration Management

### Caching Configuration
- **Implementation**: JCache API with Caffeine provider
- **Caches**: 
  - `vets` - Repository-level caching with statistics enabled
- **Configuration**: Custom CacheConfiguration bean for statistics

### Internationalization
- **Locale Resolution**: Session-based with URL parameter support (?lang=de)
- **Supported Languages**: 8 language bundles
- **Message Sources**: `messages.properties` and localized variants
- **Web Configuration**: LocaleChangeInterceptor integration

### Application Properties
```properties
# Database switching via profiles
spring.profiles.active=h2

# Caching configuration
spring.cache.type=jcache
spring.cache.cache-names=vets
spring.cache.jcache.provider=com.github.benmanes.caffeine.jcache.spi.CaffeineCachingProvider

# Thymeleaf configuration
spring.thymeleaf.cache=false (dev)
spring.thymeleaf.mode=HTML

# Actuator exposure
management.endpoints.web.exposure.include=health,info,metrics

# Pagination defaults
spring.data.web.pageable.default-page-size=5
```

### Native Image Support
- **GraalVM**: Runtime hints for all model classes
- **Resource Patterns**: Included for db/ and messages/ directories
- **Reflection Configuration**: For entity serialization

## 7. Build & Deployment Architecture

### Maven Dependencies
```xml
<!-- Core Framework -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

<!-- Database Support -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Caching -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>jcache</artifactId>
</dependency>

<!-- Frontend -->
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>webjars-locator-lite</artifactId>
</dependency>
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>bootstrap</artifactId>
</dependency>
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>font-awesome</artifactId>
</dependency>

<!-- Testing -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>mysql</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <scope>test</scope>
</dependency>
```

### Build Plugins
- **Spring Boot Maven Plugin**: For executable JAR creation
- **Git Commit ID Plugin**: Build info exposure
- **CycloneDX Plugin**: SBOM generation
- **JaCoCo Plugin**: Code coverage reporting
- **Checkstyle Plugin**: Code quality enforcement

### Deployment Artifacts
- **Docker Images**: Via Spring Boot buildpacks
- **Kubernetes**: Complete deployment manifests in `/k8s/`
- **Docker Compose**: Database service definitions
- **Health Probes**: JMX endpoints (`/livez`, `/readyz`)

## 8. Testing Architecture

### Test Framework Stack
- **Spring Boot Test**: Core testing infrastructure
- **MockMvc**: HTTP endpoint simulation
- **Mockito**: Dependency mocking
- **AssertJ**: Fluent assertions
- **Testcontainers**: Database integration testing
- **Jackson**: JSON processing validation

### Controller Layer Tests
```java
@WebMvcTest(OwnerController.class)
class OwnerControllerTests {
    // Tests: find, create, update operations
    // Mocks: OwnerRepository, PetRepository, VisitRepository
}

@WebMvcTest(VetController.class)
class VetControllerTests {
    // Tests: HTML and JSON endpoint responses
    // Validates: Pagination, content type negotiation
}

@WebMvcTest(VisitController.class)
class VisitControllerTests {
    // Tests: Visit creation flow
    // Mocks: OwnerRepository
}
```

### Service Integration Tests
```java
@DataJpaTest
@Transactional
class ClinicServiceTests {
    @AutoConfigureTestDatabase(replace = NONE)
    // Database operations:
    // - Owner CRUD operations
    // - Pet lifecycle management
    // - Visit recording
    // - Vet data retrieval
}
```

### Quality Assurance Tests
- **I18nPropertiesSyncTest**: Validates message property completeness
  - Scans: All `.java` and `.html` files in `src/main`
  - Ensures: No hardcoded strings
  - Validates: All languages have complete translations

### Performance Testing
- **JMeter Configuration** (`petclinic_test_plan.jmx`):
  - **Load**: 500 threads, 10-second ramp-up, 10 loops
  - **Endpoints Covered**:
    - Static resources (CSS, JS)
    - Owner management workflows
    - Pet creation
    - Visit scheduling
    - Vet listing
  - **Think Time**: 300ms between requests

### Utility Test Components
- **EntityUtils**: Collection-based entity lookup with exception handling
- **VetTests**: Serialization/deserialization validation

## 9. Development Environment & CI/CD

### Development Containers
- **DevContainer Configuration**:
  - Base: Ubuntu with Java 21 (Oracle JDK)
  - Features: Azure CLI, Docker-in-Docker, GitHub CLI
  - VS Code Extensions: XML support, Java pack, IntelliCode
  - Persistent Volumes: `.m2` and `.gradle` caches

- **GitPod Support**:
  - Dockerfile with Java 17.0.7-ms via SDKMAN
  - Volume mounts for build tool caches

### CI/CD Pipelines
#### GitHub Workflows
1. **Java CI with Maven**:
   - Triggers: Push/PR to main
   - Matrix: Java 17
   - Cache: Maven dependencies
   - Command: `./mvnw -B verify`

2. **Java CI with Gradle**:
   - Equivalent Gradle implementation
   - Command: `./gradlew build`

3. **Deploy and Test Cluster**:
   - Trigger: Changes to `k8s/` directory
   - Kind cluster deployment
   - Pod readiness verification
   - Timeout: 180 seconds

### Build Configuration
- **Maven Wrapper**: Version 3.3.2
- **Distribution**: Apache Maven 3.9.10
- **Type**: Script-only distribution

## 10. Observability & Operations

### Monitoring Infrastructure
- **Spring Boot Actuator**: Health, metrics, info endpoints
- **JCache Statistics**: Via JMX for cache performance
- **Build Information**: Git commit ID exposure
- **Health Probes**: Kubernetes-specific endpoints

### Error Handling
- **Global Exception Handling**: Spring Boot defaults
- **Custom Error Pages**: Thymeleaf error templates
- **Controlled Exceptions**: `/oups` endpoint for testing

### Performance Considerations
- **Caching Strategy**: Vet list caching for read-heavy operations
- **Database Indexing**: Optimized queries on frequently accessed fields
- **Pagination**: Memory-efficient large dataset handling

## 11. Frontend Architecture

### Thymeleaf Template Structure
```
templates/
├── owners/
│   ├── ownerDetails.html
│   ├── ownerForm.html
│   └── findOwners.html
├── pets/
│   ├── createOrUpdatePetForm.html
│   └── petDetails.html
├── visits/
│   └── createOrUpdateVisitForm.html
├── vets/
│   └── vetList.html
├── fragments/
│   ├── inputField.html
│   ├── layout.html
│   └── selectField.html
├── welcome.html
└── error.html
```

### UI Features
- **Responsive Design**: Bootstrap 5 framework
- **Internationalization**: Dynamic language switching
- **Reusable Components**: Fragment-based templating
- **Form Validation**: Client and server-side validation
- **Pagination Controls**: For large datasets

## 12. Microservice Decomposition Analysis

### Domain Boundary Identification
1. **Owner Service**:
   - Entities: Owner, Pet
   - Responsibilities: Customer management, pet registration
   - Database: `owners`, `pets` tables
   - API: Owner and Pet CRUD operations

2. **Visit Service**:
   - Entities: Visit
   - Responsibilities: Medical visit tracking
   - Database: `visits` table
   - Dependencies: Owner Service (pet ownership)
   - API: Visit scheduling and history

3. **Vet Service**:
   - Entities: Vet, Specialty
   - Responsibilities: Staff management, specialty tracking
   - Database: `vets`, `specialties`, `vet_specialties` tables
   - API: Vet listings and availability

4. **Shared Services**:
   - Configuration Service: Database and caching configuration
   - API Gateway: Request routing and authentication
   - Notification Service: Appointment reminders

### Decomposition Challenges
1. **Data Consistency**:
   - Owner-Pet relationships span services
   - Visit history requires cross-service joins
   - Transaction management across service boundaries

2. **UI Fragmentation**:
   - Shared layout components across domains
   - Internationalization resources duplication
   - Form validation logic distribution

3. **Migration Strategy**:
   - Database table ownership reallocation
   - API contract stabilization
   - Client-side refactoring needs

### Recommended Decomposition Path
1. **Phase 1**: Extract Vet Service (lowest coupling)
   - Clear entity boundaries
   - Minimal shared data
   - API-first design feasible

2. **Phase 2**: Split Visit Service
   - Depends on Owner Service
   - Requires asynchronous communication
   - Event-driven architecture implementation

3. **Phase 3**: Owner Service Refinement
   - Split into Customer and Pet sub-services
   - Implement service composition patterns
   - Data consistency via eventual consistency

4. **Phase 4**: Consolidate Shared Concerns
   - Extract common configuration
   - Implement API gateway
   - Centralize monitoring

### Technical Considerations for Microservices
- **Service Discovery**: Eureka or Consul integration
- **Inter-service Communication**: REST with Feign clients or messaging
- **Data Management**: Database-per-service pattern
- **Circuit Breaker**: Resilience4j implementation
- **Distributed Tracing**: Zipkin or Jaeger integration
- **Configuration Management**: Spring Cloud Config
- **API Documentation**: OpenAPI 3.0 specification

This comprehensive architectural analysis provides the foundation for a systematic microservice migration while preserving the business logic integrity and operational excellence of the Spring PetClinic application.