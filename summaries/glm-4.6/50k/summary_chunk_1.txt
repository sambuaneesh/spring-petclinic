
## Comprehensive Architectural Summary: Spring PetClinic (Part 1 of 2)

### **1. Application Overview**
- **Framework**: Spring Boot 3.5.0 with Spring MVC architecture
- **Language**: Java 17+ (Maven/Gradle build support)
- **Database**: Multi-DB support (H2/MySQL/PostgreSQL) with profile-based configuration
- **Frontend**: Thymeleaf templates with Bootstrap CSS
- **Deployment**: Docker, Kubernetes, and traditional JAR deployment options

---

### **2. Core Architecture**
#### **2.1 Layered Structure**
- **Controllers**: RESTful web layer (`/owner`, `/vet`, `/system`)
- **Repositories**: Spring Data JPA interfaces for data access
- **Models**: JPA entities with relational mappings
- **Views**: Thymeleaf HTML templates in `/templates`

#### **2.2 Key Design Patterns**
- Repository Pattern (Spring Data JPA)
- MVC with Template Views
- Entity-Relationship Mapping
- Pagination for large datasets
- Form Validation (Jakarta Validation + custom validators)

---

### **3. Domain Models & Data Schema**
#### **3.1 Core Entities**
```java
// Base Entity Hierarchy
BaseEntity (abstract) 
├── NamedEntity (name field)
│   ├── PetType (cat, dog, etc.)
│   └── Specialty (radiology, surgery)
└── Person (firstName, lastName)
    ├── Owner (address, city, telephone)
    └── Vet (specialties)

// Core Business Objects
Pet (name, birthDate, type, visits)
Visit (date, description)
```

#### **3.2 Database Relationships**
- **Owner ↔ Pet**: One-to-Many (cascade delete)
- **Pet ↔ Visit**: One-to-Many (cascade delete)
- **Pet ↔ PetType**: Many-to-One
- **Vet ↔ Specialty**: Many-to-Many
- **Indexing**: Last names, pet names, and visit IDs optimized for search

#### **3.3 Database Schemas**
- **H2**: In-memory (default) with schema: `db/h2/schema.sql`
- **MySQL**: Persistent with UTF8 support, auto-increment primary keys
- **PostgreSQL**: Persistent with IDENTITY columns, TEXT fields
- **Data Loading**: `data.sql` files per DB with sample data

---

### **4. API Endpoints**
| Controller | Path | Methods | Functionality |
|------------|------|---------|---------------|
| OwnerController | `/owners` | GET/POST | CRUD + search/pagination |
| PetController | `/owners/{ownerId}/pets` | GET/POST | Pet management under owner |
| VisitController | `/owners/{ownerId}/pets/{petId}/visits` | GET/POST | Visit scheduling |
| VetController | `/vets.html` | GET | Vet listing (paginated) |
| VetController | `/vets` | GET | JSON vet list |
| WelcomeController | `/` | GET | Homepage |
| CrashController | `/oups` | GET | Error testing endpoint |

---

### **5. Service Interactions**
#### **5.1 Repository Dependencies**
```java
OwnerController → OwnerRepository → JPA (Owners)
PetController → OwnerRepository, PetTypeRepository → JPA
VisitController → OwnerRepository → JPA (Visits via cascade)
VetController → VetRepository (Cached) → JPA
```

#### **5.2 Key Business Logic**
- **Owner Search**: Paginated by last name prefix
- **Visit Validation**: Dates cannot be future-dated
- **Pet Validation**: Unique names per owner
- **Vet Caching**: `@Cacheable("vets")` for read-heavy data
- **Transaction Boundaries**: Repository-level with `@Transactional`

---

### **6. Configuration & Deployment**
#### **6.1 Profiles**
- **Default**: H2 in-memory DB (`application.properties`)
- **MySQL**: `spring.profiles.active=mysql` 
- **PostgreSQL**: `spring.profiles.active=postgres`

#### **6.2 Docker Support**
```yaml
# docker-compose.yml services
mysql:
  image: mysql:9.2
  env: MYSQL_DATABASE=petclinic
postgres:
  image: postgres:17.5
  env: POSTGRES_DB=petclinic
```

#### **6.3 Kubernetes**
- **Secret Management**: `k8s/db.yml` with DB credentials
- **Service Exposure**: NodePort for app, ClusterIP for DB
- **Probes**: HTTP liveness/readiness (`/livez`, `/readyz`)

---

### **7. Cross-Cutting Concerns**
#### **7.1 Caching**
- **Implementation**: Caffeine with JCache API
- **Scope**: Vet lists (`CacheConfiguration.java`)
- **Configuration**: Statistics enabled via JMX

#### **7.2 Internationalization**
- **Messages**: `messages_{locale}.properties` (9 languages)
- **Resolver**: Session-based with `?lang=` param support
- **Default**: English

#### **7.3 Error Handling
- **Global**: `/error` Thymeleaf template
- **Validation**: Custom error messages (e.g., `telephone.invalid`)
- **Testing**: Dedicated error simulation endpoint

---

### **8. Development & Ops Tooling**
#### **8.1 Build Tools**
- **Maven**: Wrapper (`mvnw`) with Java 17 enforcement
- **Gradle**: Alternative build (`gradlew`)
- **CSS Compilation**: SCSS to CSS via `libsass-maven-plugin`

#### **8.2 Quality Gates**
- **Checkstyle**: No HTTP links enforcement (`nohttp-checkstyle.xml`)
- **Format**: Spring Java Format Plugin
- **Testing**: JUnit 5 + Testcontainers for DB integration

#### **8.3 Observability**
- **Actuator**: Full endpoint exposure (`management.endpoints.web.exposure.include=*`)
- **Health**: DB connectivity checks
- **Build Info**: Git commit ID and SBOM via CycloneDX

---

### **9. Security & Validation**
#### **9.1 Input Validation**
- **Fields**: `@NotBlank` on required fields
- **Custom Validators**: `PetValidator` (name/type/date)
- **Phone Format**: Regex `\d{10}` for telephone
- **Date Rules**: Birth/visit dates ≤ today

#### **9.2 Database Security**
- **MySQL**: Dedicated `petclinic` user in `user.sql`
- **Postgres**: Environment variable injection
- **H2**: In-memory (dev/test only)

---

### **Microservice Decomposition Insights**
#### **9.1 Potential Bounded Contexts**
1. **Owner Service**: Owner CRUD + search
2. **Pet Service**: Pet management with visit history
3. **Vet Service**: Vet listings + specialties
4. **Visit Service**: Visit scheduling
5. **Catalog Service**: Pet types + specialties (read-heavy)

#### **9.2 Shared Dependencies**
- **Owner ID**: Cross-service reference for pets/visits
- **Pet ID**: Required by visit service
- **Pet Types**: Referenced by pet creation forms

#### **9.3 Decomposition Challenges**
- **Transactional Boundaries**: Owner↔Pet↔Visit cascade operations
- **Data Consistency**: Visit scheduling requires pet/owner validation
- **UI Coupling**: Thymeleaf templates assume monolithic data model

This summary captures the full architectural scope required to decompose the monolith into microservices while preserving business rules and data relationships.